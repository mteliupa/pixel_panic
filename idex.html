<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Terminator — Pixel Platformer (Demo)</title>
  <style>
    html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:Inter,Segoe UI,Arial}
    #gameWrap{display:flex;flex-direction:column;align-items:center;gap:12px;padding:12px}
    canvas{image-rendering:pixelated;border:6px solid #222;background:linear-gradient(#0b0b14,#00122a)}
    .ui{display:flex;gap:10px;align-items:center;color:#cfe}
    .panel{background:rgba(0,0,0,0.45);padding:6px 10px;border-radius:8px}
    button{background:#18202b;color:#dfe;padding:6px 8px;border-radius:6px;border:1px solid #2b3945;cursor:pointer}
    a{color:#7fe}
    .credits{opacity:0.7;font-size:13px}
  </style>
</head>
<body>
  <div id="gameWrap">
    <div class="ui">
      <div class="panel">Terminator — демо платформер (single-file HTML)</div>
      <div class="panel">HP: <span id="hp">100</span></div>
      <div class="panel">Score: <span id="score">0</span></div>
      <button id="restart">Рестарт</button>
    </div>
    <canvas id="game" width="640" height="360"></canvas>
    <div class="panel credits">Управление: ← → движение, ↑ или W или Space — прыжок, S или ↓ присесть, K — выстрел, L — рывок/дэш. Нажми Рестарт если застрял. Сделал для тебя, мабой.</div>
  </div>

<script>
/* Simple 2D platformer demo in one file.
   Исправлено: входные события работают через e.code (надежнее),
   добавлена поддержка Space для прыжка, предотвращена прокрутка страницы стрелками/Space.
*/

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// --- Game State ---
let keys = {};
let entities = [];
let particles = [];
let last = 0;
let player;
let score = 0;

// --- Utility ---
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function rectsCollide(a,b){return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y}

// --- Level geometry (platforms) ---
const platforms = [
  {x:0,y:320,w:640,h:40},
  {x:60,y:250,w:140,h:16},
  {x:240,y:200,w:120,h:16},
  {x:420,y:150,w:160,h:16},
  {x:520,y:270,w:80,h:16}
];

// --- Player ---
function createPlayer(){
  return {
    type:'player', x:40, y:240, w:20, h:26,
    vx:0, vy:0, onGround:false, facing:1,
    hp:100, canDash:true, dashTimer:0, shootCool:0
  }
}

// --- Enemies ---
function spawnEnemy(x,y){
  entities.push({type:'enemy',x,y,w:18,h:18,vx: (Math.random()<0.5? -0.6:0.6), vy:0, hp:15});
}

// --- Projectiles ---
function shoot(x,y,dir){ entities.push({type:'bullet',x,y,w:6,h:4,vx:dir*6,life:60,owner:'player'}) }

// --- Particles ---
function spawnParticle(x,y,dx,dy,life){ particles.push({x,y,dx,dy,life,age:0}) }

// --- Init ---
function reset(){ entities=[]; particles=[]; player = createPlayer(); score=0; updateHUD(); spawnEnemy(320,286); spawnEnemy(500,246); }
reset();

// Input — используем e.code (KeyW, ArrowUp, Space и т.д.)
window.addEventListener('keydown', e => {
  // предотвратить прокрутку страницы при стрелках и Space
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  keys[e.code] = true;
  // рестарт по R
  if (e.code === 'KeyR') reset();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

// Restart button
document.getElementById('restart').onclick = reset;

// Main loop
function update(dt){
  // Player controls
  const walkSpeed = 1.6;
  const accel = 0.28;
  const gravity = 0.32;
  const jumpPower = -6.6;

  // Horizontal input (use e.code names)
  let left = keys['ArrowLeft'] || keys['KeyA'];
  let right = keys['ArrowRight'] || keys['KeyD'];
  let up = keys['ArrowUp'] || keys['KeyW'] || keys['Space'];
  let down = keys['ArrowDown'] || keys['KeyS'];
  let shootKey = keys['KeyK'];
  let dashKey = keys['KeyL'];

  // Facing
  if(left) player.facing = -1;
  if(right) player.facing = 1;

  // Walk
  if(left) player.vx -= accel;
  if(right) player.vx += accel;
  player.vx = clamp(player.vx, -walkSpeed*2, walkSpeed*2);
  // friction
  if(!left && !right) player.vx *= 0.86;

  // Jump (only when on ground)
  if(up && player.onGround){ player.vy = jumpPower; player.onGround=false; spawnParticle(player.x+player.w/2, player.y+player.h, (Math.random()-0.5)*1.2, -1.5, 18); }

  // Dash
  if(dashKey && player.canDash){ player.dashTimer = 12; player.canDash=false; player.vx = player.facing*6; spawnParticle(player.x, player.y+6, -player.facing*1.6, -0.2,24) }
  if(player.dashTimer>0){ player.dashTimer--; }
  else { /* recover dash on ground */ if(player.onGround) player.canDash=true }

  // Shooting
  if(shootKey && player.shootCool<=0){ shoot(player.x + (player.facing>0? player.w: -6) + 8, player.y+10, player.facing); player.shootCool = 12; spawnParticle(player.x+player.w/2, player.y+6, player.facing*1.2, -0.6, 10) }
  if(player.shootCool>0) player.shootCool--;

  // Gravity & movement
  player.vy += gravity;
  player.x += player.vx;
  player.y += player.vy;

  // Collisions with platforms
  player.onGround = false;
  for(let p of platforms){
    // simple AABB resolution
    if(rectsCollide(player,p)){
      // find previous position approximation
      if(player.vy>0 && player.y + player.h - player.vy <= p.y + 1){ // landed on top
        player.y = p.y - player.h; player.vy = 0; player.onGround = true;
      } else if(player.vy<0 && player.y >= p.y + p.h - 1){ // hit from below
        player.y = p.y + p.h; player.vy = 0;
      } else {
        // horizontal pushout
        if(player.x < p.x) player.x = p.x - player.w - 0.1; else player.x = p.x + p.w + 0.1;
        player.vx = 0;
      }
    }
  }

  // Keep player inside world
  player.x = clamp(player.x, -40, W- player.w + 40);

  // Entities update
  for(let i=entities.length-1;i>=0;i--){ let e=entities[i];
    if(e.type==='enemy'){
      e.vy += gravity*0.9; e.y += e.vy; e.x += e.vx;
      // collide with platforms simple
      for(let p of platforms){ if(rectsCollide(e,p)){
        if(e.vy>0 && e.y + e.h - e.vy <= p.y + 2){ e.y = p.y - e.h; e.vy = 0; }
        else { if(e.x < p.x) e.x = p.x - e.w; else e.x = p.x + p.w; e.vx *= -1; }
      }}
      // collide with player
      if(rectsCollide(e,player)){ e.hp -= 30; player.hp -= 10; spawnParticle(e.x+8,e.y+8, (Math.random()-0.5)*2, -1, 20) }
      // collide with bullets
      for(let j=entities.length-1;j>=0;j--){ let b=entities[j]; if(b.type==='bullet' && b.owner==='player' && rectsCollide(e,b)){ e.hp -= 10; entities.splice(j,1); spawnParticle(b.x,b.y,b.vx*0.4, (Math.random()-0.5)*0.3, 12); }}
      if(e.hp<=0){ entities.splice(i,1); score+=50; updateHUD(); spawnParticle(e.x+e.w/2,e.y+e.h/2, (Math.random()-0.5)*2, -1.6, 30) }
    }
    if(e.type==='bullet'){
      e.x += e.vx; e.life--; if(e.life<=0) entities.splice(i,1);
      // bullet hits world
      for(let p of platforms) if(rectsCollide(e,p)){ entities.splice(i,1); break; }
    }
  }

  // Particles
  for(let i=particles.length-1;i>=0;i--){ let p=particles[i]; p.x+=p.dx; p.y+=p.dy; p.dy+=0.08; p.age++; if(p.age>p.life) particles.splice(i,1); }

  // Keep HP bounds and lose condition
  player.hp = clamp(player.hp,0,100);
  if(player.hp<=0){ // simple death
    // explode
    for(let i=0;i<20;i++) spawnParticle(player.x + Math.random()*player.w, player.y + Math.random()*player.h, (Math.random()-0.5)*5, (Math.random()-1.5)*4, 40);
    // reset after explosion particles remain
    setTimeout(reset, 700);
  }
}

function updateHUD(){ document.getElementById('hp').innerText = Math.round(player.hp); document.getElementById('score').innerText = score; }

// Draw pixel character (Terminator-ish)
function drawPlayer(x,y,facing){
  // body blocks scale
  const s=2; // pixel scale
  ctx.save(); ctx.translate(x,y);
  ctx.scale(s,s);
  // torso (metallic)
  ctx.fillStyle='#2b2b2b'; ctx.fillRect(0,0,10,12);
  // red eye
  ctx.fillStyle='#a00'; ctx.fillRect(facing>0?8:0,2,2,1);
  // head
  ctx.fillStyle='#111'; ctx.fillRect(2, -6,6,6);
  ctx.fillStyle='#444'; ctx.fillRect(2,-4,6,2);
  // arm
  ctx.fillStyle='#2b2b2b'; ctx.fillRect(facing>0?10:-4,2,4,3);
  // legs
  ctx.fillRect(1,12,3,6); ctx.fillRect(6,12,3,6);
  ctx.restore();
}

function draw(){
  // background
  ctx.clearRect(0,0,W,H);
  // sky gradient
  let g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,'#00122a'); g.addColorStop(1,'#000'); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);

  // simple parallax distant shapes
  ctx.fillStyle='rgba(255,255,255,0.02)'; for(let i=0;i<60;i++) ctx.fillRect((i*37)%W, 30 + (i%7)*12, 18,6);

  // platforms
  for(let p of platforms){ ctx.fillStyle='#223'; ctx.fillRect(p.x, p.y, p.w, p.h); ctx.fillStyle='#2b6'; ctx.fillRect(p.x, p.y, Math.min(6,p.w), 2); }

  // player shadow
  ctx.fillStyle='rgba(0,0,0,0.45)'; ctx.fillRect(player.x+2, player.y+player.h+2, player.w-4, 3);

  // particles
  for(let p of particles){ ctx.fillStyle='rgba(255,180,60,'+ (1 - p.age/p.life) +')'; ctx.fillRect(Math.round(p.x), Math.round(p.y), 2,2); }

  // entities
  for(let e of entities){
    if(e.type==='enemy'){
      // crude enemy sprite
      ctx.fillStyle='#8b1f1f'; ctx.fillRect(e.x,e.y,e.w,e.h);
      ctx.fillStyle='#300'; ctx.fillRect(e.x+4,e.y+4,6,2);
    }
    if(e.type==='bullet'){
      ctx.fillStyle='#ffd'; ctx.fillRect(e.x,e.y,e.w,e.h);
    }
  }

  // draw player pixel art
  drawPlayer(player.x, player.y, player.facing);

  // HUD text
  ctx.fillStyle='#9f9'; ctx.font='12px monospace'; ctx.fillText('HP: '+Math.round(player.hp), 8, 14);
}

// Game loop with fixed timestep
let acc=0; const step=1000/60;
function loop(t){ if(!last) last=t; let dt = t-last; last=t; acc += dt; while(acc >= step){ update(step/1000); acc -= step }
 updateHUD(); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// small helper: spawn occasional enemies
setInterval(()=>{ if(Math.random()<0.6) spawnEnemy(640 - 40, 260 + Math.random()*20); }, 3000);

</script>
</body>
</html>
